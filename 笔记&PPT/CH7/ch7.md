# CH7

## 7.3设备更新与中心选址

### 一、指定顶点对之间的最短路径算法

对于图G每一条边$e_i$都规定一个正实数$a(e_i)$与之对应，所得到的图称为赋权图，称$e(a_i)$为边$e(a_i)$的权，边$(v_i,v_j)$上的权称为$a(v_i,v_j)$。
连通的赋权图称为网络。
对于赋权图G，$\forall s,t\in V$,G中的$(s,t)$一路称为**最短路**，如果它的各边的权和是G中任一条$(s,t)$一路中个边权和最小的。
赋权图的带权邻接矩阵$A=(a_{ij})_{n\times n}$，其中
$$
a_{ij}=\begin{cases}
    a(e_k)&\text{if }存在e_k\in E，使得e_k=v_iv_j \\
    \infty&\text{else}
\end{cases}
$$
找寻$(s,t)$最短路最有效的算法是Dijkstra算法：其主要思路是假定我们已经知道了在图中与起点s有最短路径的m个顶点以及从s到这些顶点间的最短路径，然后求出第m+1个顶点使之与前m个顶点有相同的属性。其实现方法是比较法。
对于每一个未着色的顶点y，考虑所有已着色的顶点x，从$s_1$通过已着色的顶点到y的不同路径中选出它们中的最短路径，从而也就确定了新染色的点和相应的最短路径，不断重复上述过程直至求得从s到t的最短路径为止。
#### Dijkstra算法步骤
1.最初，所有的边和顶点均为着色，对每一顶点x指定一个数d(x)，表示从s到x仅使用已知着色顶点作为中间顶点的最短路径长度。
2.令d(s)=0，并对所有$x\not ={s}$，有$d(x)=\infty$，对于顶点S卓德并令y=s。
3.对于每一个未着色顶点x，重新定义$d(x)$如下：
$d(x)=\min\{d(x),d(y)+a(y,x)\}$
如果对于所有未着色的顶点x，$d(x)=\infty$，则算法停止，因为此时从S到任一围桌的的顶点都没有路，也就不存在从S到t的路径。否则找出一个具有最小的d(x)的值的顶点，对其着色并令y=x。
4.重复步骤3直到顶点t已经着色是为止，算法终止。从S到t的最短路径已求出。

### 二、所有顶点间的最短路径算法

一个图中所有顶点间的最短路径算法是一个更具有普遍意义的问题。
以下介绍Floyed（福劳德）提出的算法，其具体思路如下：对一个有n个顶点的图G，将顶点用n个整数（从1到n）进行编号。令$d^{m}_{ij}$表示从顶点i到j的一条 只允许前m个顶点作为中间顶点时的最短距离。如果这样的路不存在，则$d^m_{ij}=\infty$。
由此可知，$d^0_{ij}$
表示从顶点i到j的边长度（如果没有这条边存在，则$d^0_{ij}=\infty$），显然$d^0_{ij}=0$。而$d^n_{ij}$就是所求的最短路径距离。


#### Floyed算法步骤

- 1.将图中各顶点编号为1,2,...,n，确定矩阵$D_0$，如果顶点i和j之间有边相连，$d^0_{ij}$等于该边长度，否则$d^0_{ij}=\infty$，而$d^0_{ij}=0$
- 2.对于m=1,2,...,n，依次利用递归公式$d^m_{ij}=\min\{d^{m-1}_{im}+d^{m-1}_{mj},d^{m-1}_{ij}\}$
  由已知的$D^{m-1}$各元素确定$D^m$的各元素值。每确定一个元素，可记下其所代表的路径，在算法终止时，不仅通过$D^n$矩阵的各元素知道了各点之间的最短距离，而且也知道了形成这条路径的各边的组合。

### 三、应用举例

在通信传输网中，要找出二点间信息传递具有最大可靠性的路径；
在城市建设中，要设计出费用最小的交通运输干线；
在交通运输中，希望选择一个最佳最经济的路线（距离最短或单位运价最低）等等。
这些问题都等价于找一个图的最短路径问题。
最短路模型还可以应用于中心选址的问题。所谓中心选址问题就是在一网络中选择一点，建立公用服务设施，为该网络中的点提供服务，使得服务效率最高。比如一个区域的消防站、自来水厂、学校、变电站、银行、商店等选址。为了提高服务效率，自然的想法是将这些设施建立在中心地点。对于规则的网络，例如圆形、矩形等，中心地点是显而易见的，然而对于更多的网络是不规则的。因此，我们引入下面定义。
设网络N有n个点$v_1,v_2,...,v_n$，$d_{ij}$表示点$v_i、v_j$之间的距离（即最短陆的长度），并记$d_{ii}=0(i=1,2,...,n)$
==定义1==：记$d(v_i)=\max\limits_{1\le j\le n}d_{ij},I=\min\limits_{1\le i\le n}\{d(v_i)\}$。若$d(v_x)=I$，则称点$v_k$为网络N的中心，I为直径。
==定义2==：令$h(v_i)=\sum_{j=1}^{n}d_{ij}(i=1,2,...,n)$，若$h(v_k)=\min\limits_{1\le i\le n}\{h(v_i)\}$，则称$v_k$为网络N的中心。

## 7.4天然气管道铺设方案

连通的无圈图称为==树==。**树是最简单但又是十分重要的一类图**，它在许多学科领域中有广泛的应用，例如分子结构、电网络分析等。最短连接问题与树有关，学科分类和一些决策过程也往往可以用树的形式表示。
若$G_1$事故连通图$G_2$的子图，其顶点想同，则称$G_1$$G_2$的*生成子图*。
若$G_1$事故连通图$G_2$的生成子图，且$G_1$是树，则称$G_1$$G_2$的*生成树*。

对连通图$G=(V,E)$的每一条边$e\in E$赋以相应的实数权$w(e)$，得到一个**网络**，记为$N=(V,E,W)$。设$T=(V,E')$是N的一个生成树，令$W(T0=\sum\limits_{e\in E}w(e)$，则$W(T)$称为T的权，N中权最小的生成树称为N的**最小生成树**。
接下来介绍如何在给定网络$N=(V,E,W)$内求最小生成树的两种方法。预设网络的点数为n，此时最小生成树的变数为n-1。

### 算法1：Kruskal克鲁斯凯尔
算法1的中心思想是每次添加权尽可能小的边，使新的图无圈，知道生成最小生成树为止，亦称“最小边的加入法”。
#### 步骤
- 1.把N内的所有边按照权的非减次序排列
- 2.按1排列的次序检查N中每一条边，如果此边与以得到的边不产生圈，测取这一条边为解的一部分。
- 3.重复2，直到取到n-1条边，算法终止。此时以V为顶点集，以取到的n-1条边，为边集的图就是最小生成树。

### 算法2：Prim普莱姆

prim算法是一种迭代算法，每次迭代产生组成网络N最小生成树T的一条边。prim算法基于一个事实：如果已经直到T中的一些边，其端点集为S，则S是N的顶点V的一个子集。以$\Phi(S)$记为一个端点在S中、另一端在V\S中的所有边组成的集合，由于最小生成树T是N的连通生成子图，$\Phi(S)$权最小的一条边，应该也是N的最小生成树T中的一条边。

#### 步骤
设$V(G)=(v_1,v_2,...v_n)$，$e_{ij}=(v_i,v_j)\in E(G)，w_{ij}=w(e_{ij})$为边$e_{ij}$的权。如果$v_i,v_j$之间无边相连，则取$w_{ij}=\infty$。下面用顶点的下标表示S中的顶点：
- 1.$T=\phi,S={1},R={2,3,...,n},U_j=w_{ij}$，此处$i=1\in S,j\in R$。
- 2.设$\min\limits_{j\in R}U_j=w_{ik}$，记$U_k=w_{ik}$。以$S\bigcup\{k\}$代替S，$R$\ $\{k\}$代替R，$T\bigcup \{e_{ik}\}$代替T。
- 3.若$R=\phi$，算法终止，此时T即为所求；否则，对每个$j\in R$，以$\min\limits_{j\in R}U_j=w_{ik}$代替$U_j$，重复2。

### 总结
克鲁斯凯尔用于手工计算小型网络的最小生成树是比较好，而且直观易懂，但应用较大型网络时效率不高，基于这种算法的计算机软件也较难实现。普赖姆方法克服了这些缺点，但遗憾的是普赖姆方法应用于小型问题时却过分的繁复。
许多实际问题，如在若干个城市之间建造铁路网、输电网或通信网等，都可归纳为寻求连通赋权图（网络）的最小生成树问题。